<snippet>
<content><![CDATA[
${1:# acme_accountkey_path: The path to the accountkey for the `acme' 
# acme_chain: Include the intermediate certificate to the 
# acme_challenge_path: The path to the ACME challenge directory that is 
# attributes: The attributes the resulting file or directory 
# backup: Create a backup file including a timestamp so 
# csr_path: Path to the Certificate Signing Request (CSR) 
# entrust_api_client_cert_key_path: The path to the private key of the client 
# entrust_api_client_cert_path: The path to the client certificate used to 
# entrust_api_key: The key (password) for authentication to the 
# entrust_api_specification_path: The path to the specification file defining the 
# entrust_api_user: The username for authentication to the Entrust 
# entrust_cert_type: Specify the type of certificate requested. This 
# entrust_not_after: The point in time at which the certificate stops 
# entrust_requester_email: The email of the requester of the certificate 
# entrust_requester_name: The name of the requester of the certificate 
# entrust_requester_phone: The phone number of the requester of the 
# extended_key_usage: The `extended_key_usage' extension field must 
# extended_key_usage_strict: If set to `yes', the `extended_key_usage' 
# force: Generate the certificate, even if it already 
# group: Name of the group that should own the 
# has_expired: Checks if the certificate is expired/not expired 
# invalid_at: The certificate must be invalid at this point in 
# issuer: The key/value pairs that must be present in the 
# issuer_strict: If set to `yes', the `issuer' field must contain 
# key_usage: The `key_usage' extension field must contain all 
# key_usage_strict: If set to `yes', the `key_usage' extension field 
# mode: The permissions the resulting file or directory 
# not_after: The certificate must expire at this point in 
# not_before: The certificate must start to become valid at 
# ownca_create_authority_key_identifier: Create a Authority Key Identifier from the CA's 
# ownca_create_subject_key_identifier: Whether to create the Subject Key Identifier 
# ownca_digest: The digest algorithm to be used for the `ownca' 
# ownca_not_after: The point in time at which the certificate stops 
# ownca_not_before: The point in time the certificate is valid from. 
# ownca_path: Remote absolute path of the CA (Certificate 
# ownca_privatekey_passphrase: The passphrase for the `ownca_privatekey_path'. 
# ownca_privatekey_path: Path to the CA (Certificate Authority) private 
# ownca_version: The version of the `ownca' certificate. Nowadays 
# owner: Name of the user that should own the 
# path: (required) Remote absolute path where the 
# privatekey_passphrase: The passphrase for the `privatekey_path'. This 
# privatekey_path: Path to the private key to use when signing the 
# provider: Name of the provider to use to generate/retrieve 
# select_crypto_backend: Determines which crypto backend to use. The 
# selevel: The level part of the SELinux file context. This 
# selfsigned_create_subject_key_identifier: Whether to create the Subject Key Identifier 
# selfsigned_digest: Digest algorithm to be used when self-signing 
# selfsigned_not_after: The point in time at which the certificate stops 
# selfsigned_not_before: The point in time the certificate is valid from. 
# selfsigned_version: Version of the `selfsigned' certificate. 
# serole: The role part of the SELinux file context. When 
# setype: The type part of the SELinux file context. When 
# seuser: The user part of the SELinux file context. By 
# signature_algorithms: A list of algorithms that you would accept the 
# state: Whether the certificate should exist or not, 
# subject: The key/value pairs that must be present in the 
# subject_alt_name: The `subject_alt_name' extension field must 
# subject_alt_name_strict: If set to `yes', the `subject_alt_name' 
# subject_strict: If set to `yes', the `subject' field must 
# unsafe_writes: Influence when to use atomic operation to 
# valid_at: The certificate must be valid at this point in 
# valid_in: The certificate must still be valid at this 
# version: The version of the certificate. Nowadays it 
}- name: ${2:Name for openssl_certificate module.}
  openssl_certificate:
${3:   ${4:acme_accountkey_path}: ${5:"#"}}
${6:   ${7:acme_chain}: ${8:"#"}}
${9:   ${10:acme_challenge_path}: ${11:"#"}}
${12:   ${13:attributes}: ${14:"#"}}
${15:   ${16:backup}: ${17:"#"}}
${18:   ${19:csr_path}: ${20:"#"}}
${21:   ${22:entrust_api_client_cert_key_path}: ${23:"#"}}
${24:   ${25:entrust_api_client_cert_path}: ${26:"#"}}
${27:   ${28:entrust_api_key}: ${29:"#"}}
${30:   ${31:entrust_api_specification_path}: ${32:"#"}}
${33:   ${34:entrust_api_user}: ${35:"#"}}
${36:   ${37:entrust_cert_type}: ${38:"#"}}
${39:   ${40:entrust_not_after}: ${41:"#"}}
${42:   ${43:entrust_requester_email}: ${44:"#"}}
${45:   ${46:entrust_requester_name}: ${47:"#"}}
${48:   ${49:entrust_requester_phone}: ${50:"#"}}
${51:   ${52:extended_key_usage}: ${53:"#"}}
${54:   ${55:extended_key_usage_strict}: ${56:"#"}}
${57:   ${58:force}: ${59:"#"}}
${60:   ${61:group}: ${62:"#"}}
${63:   ${64:has_expired}: ${65:"#"}}
${66:   ${67:invalid_at}: ${68:"#"}}
${69:   ${70:issuer}: ${71:"#"}}
${72:   ${73:issuer_strict}: ${74:"#"}}
${75:   ${76:key_usage}: ${77:"#"}}
${78:   ${79:key_usage_strict}: ${80:"#"}}
${81:   ${82:mode}: ${83:"#"}}
${84:   ${85:not_after}: ${86:"#"}}
${87:   ${88:not_before}: ${89:"#"}}
${90:   ${91:ownca_create_authority_key_identifier}: ${92:"#"}}
${93:   ${94:ownca_create_subject_key_identifier}: ${95:"#"}}
${96:   ${97:ownca_digest}: ${98:"#"}}
${99:   ${100:ownca_not_after}: ${101:"#"}}
${102:   ${103:ownca_not_before}: ${104:"#"}}
${105:   ${106:ownca_path}: ${107:"#"}}
${108:   ${109:ownca_privatekey_passphrase}: ${110:"#"}}
${111:   ${112:ownca_privatekey_path}: ${113:"#"}}
${114:   ${115:ownca_version}: ${116:"#"}}
${117:   ${118:owner}: ${119:"#"}}
${120:   ${121:path}: ${122:"#"}}
${123:   ${124:privatekey_passphrase}: ${125:"#"}}
${126:   ${127:privatekey_path}: ${128:"#"}}
${129:   ${130:provider}: ${131:"#"}}
${132:   ${133:select_crypto_backend}: ${134:"#"}}
${135:   ${136:selevel}: ${137:"#"}}
${138:   ${139:selfsigned_create_subject_key_identifier}: ${140:"#"}}
${141:   ${142:selfsigned_digest}: ${143:"#"}}
${144:   ${145:selfsigned_not_after}: ${146:"#"}}
${147:   ${148:selfsigned_not_before}: ${149:"#"}}
${150:   ${151:selfsigned_version}: ${152:"#"}}
${153:   ${154:serole}: ${155:"#"}}
${156:   ${157:setype}: ${158:"#"}}
${159:   ${160:seuser}: ${161:"#"}}
${162:   ${163:signature_algorithms}: ${164:"#"}}
${165:   ${166:state}: ${167:"#"}}
${168:   ${169:subject}: ${170:"#"}}
${171:   ${172:subject_alt_name}: ${173:"#"}}
${174:   ${175:subject_alt_name_strict}: ${176:"#"}}
${177:   ${178:subject_strict}: ${179:"#"}}
${180:   ${181:unsafe_writes}: ${182:"#"}}
${183:   ${184:valid_at}: ${185:"#"}}
${186:   ${187:valid_in}: ${188:"#"}}
${189:   ${190:version}: ${191:"#"}}
${192:${193:   become: ${194:true}} 
${195:   become_method: ${196:su}} 
${197:   become_user: ${198:nobody}} 
${199:   become_flags: ${200:"-s /bin/sh"}}} 
${201:   when: ${202:variable is defined}} 
${203:   with_items: ${204:array}} 
]]></content>
	<tabTrigger>openssl_certificate</tabTrigger>
	<scope>source.yaml,source.ansible</scope>
</snippet>
